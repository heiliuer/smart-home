C51 COMPILER V9.55   SMARTHOME                                                             05/08/2016 03:55:30 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE SMARTHOME
OBJECT MODULE PLACED IN .\Objects\smarthome.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil_v5\C51\BIN\C51.EXE smarthome.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXT
                    -END PRINT(.\Listings\smarthome.lst) TABS(2) OBJECT(.\Objects\smarthome.obj)

line level    source

   1          #include<reg52.h>               
   2          
   3          //函数声明 
   4          void SendStr(unsigned char *s);
   5          void DelayUs2x(unsigned char t);
   6          void DelayMs(unsigned char t);
   7          void sendIOData();
   8          
   9          unsigned int times = 0;
  10          
  11          unsigned char send[5];
  12          
  13          sbit KEY1 = P0 ^ 0;  //定义按键输入端口
  14          sbit KEY2 = P0 ^ 1;  //定义按键输入端口
  15          sbit LED1 = P1 ^ 0;
  16          sbit LED2 = P1 ^ 1;
  17          int flag1 = 1;
  18          int flag2 = 1;
  19          
  20          /*------------------------------------------------
  21           串口初始化
  22           ------------------------------------------------*/
  23          void InitUART(void) {
  24   1        SCON = 0x50;            // SCON: 模式 1, 8-bit UART, 使能接收  
  25   1        TMOD |= 0x20;               // TMOD: timer 1, mode 2, 8-bit 重装
  26   1        TH1 = 0xFD;               // TH1:  重装值 9600 波特率 晶振 11.0592MHz  
  27   1        TR1 = 1; //启动定时器                
  28   1        EA = 1;                  //打开总中断
  29   1        ES = 1;                  //打开串口中断
  30   1      }
  31          void SendByte(unsigned char dat);
  32          /*------------------------------------------------
  33           主函数
  34           ------------------------------------------------*/
  35          
  36          void main(void) {
  37   1        int i = 100;
  38   1        InitUART();
  39   1      
  40   1        //先输出0，再输出1，才能真正输出
  41   1        P0 = 0x00;
  42   1        P1 = 0x00;
  43   1        P2 = 0x00;
  44   1        P3 = 0x00;
  45   1      
  46   1        P0 = 0xff;
  47   1        P1 = 0xff;
  48   1        P2 = 0xff;
  49   1        P3 = 0xff;
  50   1      
  51   1        KEY1 = 1; //按键输入端口电平置高
  52   1        KEY2 = 1;
  53   1      
  54   1        while (1) {
C51 COMPILER V9.55   SMARTHOME                                                             05/08/2016 03:55:30 PAGE 2   

  55   2      //    SendByte(0xff);
  56   2      //    while(i-->0){
  57   2      //      j=100;
  58   2      //      while(j-->0);
  59   2      //    }
  60   2      
  61   2          if (!KEY1 || !KEY2)  //如果检测到低电平，说明按键按下
  62   2              {
  63   3            DelayMs(10); //延时去抖，一般10-20ms
  64   3            if (!KEY1 || !KEY2)     //再次确认按键是否按下，没有按下则退出
  65   3                {
  66   4              flag1 = !KEY1;
  67   4              flag2 = !KEY2;
  68   4              while (!KEY1 || !KEY2)
  69   4                ;     //如果确认按下按键等待按键释放，没有释放则一直等待
  70   4      
  71   4              if (flag1) {
  72   5                LED1 = !LED1;
  73   5              }
  74   4              if (flag2) {
  75   5                LED2 = !LED2;
  76   5              }
  77   4              sendIOData();
  78   4              
  79   4            }
  80   3          }
  81   2          
  82   2          //主循环中添加其他需要一直工作的程序
  83   2      
  84   2        }
  85   1      }
  86          
  87          /*------------------------------------------------
  88           发送一个字节
  89           ------------------------------------------------*/
  90          void SendByte(unsigned char dat) {
  91   1        SBUF = dat;
  92   1        while (!TI)
  93   1          ;
  94   1        TI = 0;
  95   1      }
  96          /*------------------------------------------------
  97           发送一个字符串
  98           ------------------------------------------------*/
  99          void SendStr(unsigned char *s) {
 100   1        while (*s != '\n')     // \0 表示字符串结束标志，通过检测是否字符串末尾
 101   1        {
 102   2          SendByte(*s);
 103   2          s++;
 104   2        }
 105   1      }
 106          
 107          void receive_wait() {
 108   1        while (!RI)
 109   1          ;
 110   1        RI = 0;
 111   1      }
 112          
 113          void sendIOData() {
 114   1        send[0] = P0;
 115   1        send[1] = P1;
 116   1        send[2] = P2;
C51 COMPILER V9.55   SMARTHOME                                                             05/08/2016 03:55:30 PAGE 3   

 117   1        send[3] = P3;
 118   1        send[4] = '\n';
 119   1        SendStr(send);
 120   1      }
 121          
 122          /*------------------------------------------------
 123           串口数据 控制组件
 124           ------------------------------------------------*/
 125          void UART_SER()
 126          interrupt 4
 127          {
 128   1        if(RI)                        //判断是接收中断产生
 129   1        {
 130   2          RI=0;                      //标志位清零
 131   2          switch(SBUF) {
 132   3            case 0xaa:                      //读取所有IO口的电平状态
 133   3            receive_wait();
 134   3            sendIOData();
 135   3            break;
 136   3            case 0xa0:            //设置P0的8位电平
 137   3            receive_wait();
 138   3            P0=SBUF;
 139   3            sendIOData();
 140   3            break;
 141   3            case 0xa1:            //设置P1的8位电平
 142   3            receive_wait();
 143   3            P1=SBUF;
 144   3            sendIOData();
 145   3            break;
 146   3            case 0xa2:            //设置P2的8位电平
 147   3            receive_wait();
 148   3            P2=SBUF;
 149   3            sendIOData();
 150   3            break;
 151   3            case 0xa3:            //设置P3的8位电平
 152   3            receive_wait();
 153   3            P3=P3&0x03|SBUF;
 154   3            sendIOData();
 155   3            break;
 156   3          }
 157   2        }
 158   1      //  if(TI)                        //如果是发送标志位，清零
 159   1      //  {
 160   1      //    TI=0;
 161   1      //  }
 162   1      }
 163          
 164          /*------------------------------------------------
 165           uS延时函数，含有输入参数 unsigned char t，无返回值
 166           unsigned char 是定义无符号字符变量，其值的范围是
 167           0~255 这里使用晶振12M，精确延时请使用汇编,大致延时
 168           长度如下 T=tx2+5 uS 
 169           ------------------------------------------------*/
 170          void DelayUs2x(unsigned char t) {
 171   1        while (--t)
 172   1          ;
 173   1      }
 174          /*------------------------------------------------
 175           mS延时函数，含有输入参数 unsigned char t，无返回值
 176           unsigned char 是定义无符号字符变量，其值的范围是
 177           0~255 这里使用晶振12M，精确延时请使用汇编
 178           ------------------------------------------------*/
C51 COMPILER V9.55   SMARTHOME                                                             05/08/2016 03:55:30 PAGE 4   

 179          void DelayMs(unsigned char t) {
 180   1      
 181   1        while (t--) {
 182   2          //大致延时1mS
 183   2          DelayUs2x(245);
 184   2          DelayUs2x(245);
 185   2        }
 186   1      }
 187          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    309    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
